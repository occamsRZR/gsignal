.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Template::View 3"
.TH Template::View 3 "2011-07-25" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Template::View \- customised view of a template processing context
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&    # define a view
\&    [% VIEW view
\&            # some standard args
\&            prefix        => 'my_', 
\&            suffix        => '.tt2',
\&            notfound      => 'no_such_file'
\&            ...
.Ve
.PP
.Vb 8
\&            # any other data
\&            title         => 'My View title'
\&            other_item    => 'Joe Random Data'
\&            ...
\&    %]
\&       # add new data definitions, via 'my' self reference
\&       [% my.author = "$abw.name <$abw.email>" %]
\&       [% my.copy   = "&copy; Copyright 2000 $my.author" %]
.Ve
.PP
.Vb 4
\&       # define a local block
\&       [% BLOCK header %]
\&       This is the header block, title: [% title or my.title %]
\&       [% END %]
.Ve
.PP
.Vb 1
\&    [% END %]
.Ve
.PP
.Vb 3
\&    # access data items for view
\&    [% view.title %]
\&    [% view.other_item %]
.Ve
.PP
.Vb 3
\&    # access blocks directly ('include_naked' option, set by default)
\&    [% view.header %]
\&    [% view.header(title => 'New Title') %]
.Ve
.PP
.Vb 2
\&    # non-local templates have prefix/suffix attached
\&    [% view.footer %]           # => [% INCLUDE my_footer.tt2 %]
.Ve
.PP
.Vb 3
\&    # more verbose form of block access
\&    [% view.include( 'header', title => 'The Header Title' ) %]
\&    [% view.include_header( title => 'The Header Title' ) %]
.Ve
.PP
.Vb 2
\&    # very short form of above ('include_naked' option, set by default)
\&    [% view.header( title => 'The Header Title' ) %]
.Ve
.PP
.Vb 2
\&    # non-local templates have prefix/suffix attached
\&    [% view.footer %]           # => [% INCLUDE my_footer.tt2 %]
.Ve
.PP
.Vb 5
\&    # fallback on the 'notfound' template ('my_no_such_file.tt2')
\&    # if template not found 
\&    [% view.include('missing') %]
\&    [% view.include_missing %]
\&    [% view.missing %]
.Ve
.PP
.Vb 2
\&    # print() includes a template relevant to argument type
\&    [% view.print("some text") %]     # type=TEXT, template='text'
.Ve
.PP
.Vb 3
\&    [% BLOCK my_text.tt2 %]           # 'text' with prefix/suffix
\&       Text: [% item %]
\&    [% END %]
.Ve
.PP
.Vb 2
\&    # now print() a hash ref, mapped to 'hash' template
\&    [% view.print(some_hash_ref) %]   # type=HASH, template='hash'
.Ve
.PP
.Vb 3
\&    [% BLOCK my_hash.tt2 %]           # 'hash' with prefix/suffix
\&       hash keys: [% item.keys.sort.join(', ')
\&    [% END %]
.Ve
.PP
.Vb 2
\&    # now print() a list ref, mapped to 'list' template
\&    [% view.print(my_list_ref) %]     # type=ARRAY, template='list'
.Ve
.PP
.Vb 3
\&    [% BLOCK my_list.tt2 %]           # 'list' with prefix/suffix
\&       list: [% item.join(', ') %]
\&    [% END %]
.Ve
.PP
.Vb 2
\&    # print() maps 'My::Object' to 'My_Object'
\&    [% view.print(myobj) %]
.Ve
.PP
.Vb 3
\&    [% BLOCK my_My_Object.tt2 %]
\&       [% item.this %], [% item.that %]
\&    [% END %]
.Ve
.PP
.Vb 3
\&    # update mapping table
\&    [% view.map.ARRAY = 'my_list_template' %]
\&    [% view.map.TEXT  = 'my_text_block'    %]
.Ve
.PP
.Vb 4
\&    # change prefix, suffix, item name, etc.
\&    [% view.prefix = 'your_' %]
\&    [% view.default = 'anyobj' %]
\&    ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1TODO\s0
.SH "METHODS"
.IX Header "METHODS"
.Sh "new($context, \e%config)"
.IX Subsection "new($context, %config)"
Creates a new Template::View presenting a custom view of the specified 
\&\f(CW$context\fR object.
.PP
A reference to a hash array of configuration options may be passed as the 
second argument.
.IP "prefix" 4
.IX Item "prefix"
Prefix added to all template names.
.Sp
.Vb 2
\&    [% USE view(prefix => 'my_') %]
\&    [% view.view('foo', a => 20) %]     # => my_foo
.Ve
.IP "suffix" 4
.IX Item "suffix"
Suffix added to all template names.
.Sp
.Vb 2
\&    [% USE view(suffix => '.tt2') %]
\&    [% view.view('foo', a => 20) %]     # => foo.tt2
.Ve
.IP "map" 4
.IX Item "map"
Hash array mapping reference types to template names.  The \fIprint()\fR 
method uses this to determine which template to use to present any
particular item.  The \s-1TEXT\s0, \s-1HASH\s0 and \s-1ARRAY\s0 items default to 'test', 
\&'hash' and 'list' appropriately.
.Sp
.Vb 3
\&    [% USE view(map => { ARRAY   => 'my_list', 
\&                         HASH    => 'your_hash',
\&                         My::Foo => 'my_foo', } ) %]
.Ve
.Sp
.Vb 4
\&    [% view.print(some_text) %]         # => text
\&    [% view.print(a_list) %]            # => my_list
\&    [% view.print(a_hash) %]            # => your_hash
\&    [% view.print(a_foo) %]             # => my_foo
.Ve
.Sp
.Vb 3
\&    [% BLOCK text %]
\&       Text: [% item %]
\&    [% END %]
.Ve
.Sp
.Vb 3
\&    [% BLOCK my_list %]
\&       list: [% item.join(', ') %]
\&    [% END %]
.Ve
.Sp
.Vb 3
\&    [% BLOCK your_hash %]
\&       hash keys: [% item.keys.sort.join(', ')
\&    [% END %]
.Ve
.Sp
.Vb 3
\&    [% BLOCK my_foo %] 
\&       Foo: [% item.this %], [% item.that %]
\&    [% END %]
.Ve
.IP "method" 4
.IX Item "method"
Name of a method which objects passed to \fIprint()\fR may provide for presenting
themselves to the view.  If a specific map entry can't be found for an 
object reference and it supports the method (default: 'present') then 
the method will be called, passing the view as an argument.  The object 
can then make callbacks against the view to present itself.
.Sp
.Vb 1
\&    package Foo;
.Ve
.Sp
.Vb 4
\&    sub present {
\&        my ($self, $view) = @_;
\&        return "a regular view of a Foo\en";
\&    }
.Ve
.Sp
.Vb 4
\&    sub debug {
\&        my ($self, $view) = @_;
\&        return "a debug view of a Foo\en";
\&    }
.Ve
.Sp
In a template:
.Sp
.Vb 2
\&    [% USE view %]
\&    [% view.print(my_foo_object) %]     # a regular view of a Foo
.Ve
.Sp
.Vb 2
\&    [% USE view(method => 'debug') %]
\&    [% view.print(my_foo_object) %]     # a debug view of a Foo
.Ve
.IP "default" 4
.IX Item "default"
Default template to use if no specific map entry is found for an item.
.Sp
.Vb 1
\&    [% USE view(default => 'my_object') %]
.Ve
.Sp
.Vb 1
\&    [% view.print(objref) %]            # => my_object
.Ve
.Sp
If no map entry or default is provided then the view will attempt to 
construct a template name from the object class, substituting any 
sequence of non-word characters to single underscores, e.g.
.Sp
.Vb 2
\&    # 'fubar' is an object of class Foo::Bar
\&    [% view.print(fubar) %]             # => Foo_Bar
.Ve
.Sp
Any current prefix and suffix will be added to both the default template 
name and any name constructed from the object class.
.IP "notfound" 4
.IX Item "notfound"
Fallback template to use if any other isn't found.
.IP "item" 4
.IX Item "item"
Name of the template variable to which the \fIprint()\fR method assigns the current
item.  Defaults to 'item'.
.Sp
.Vb 5
\&    [% USE view %]
\&    [% BLOCK list %] 
\&       [% item.join(', ') %] 
\&    [% END %]
\&    [% view.print(a_list) %]
.Ve
.Sp
.Vb 5
\&    [% USE view(item => 'thing') %]
\&    [% BLOCK list %] 
\&       [% thing.join(', ') %] 
\&    [% END %]
\&    [% view.print(a_list) %]
.Ve
.IP "view_prefix" 4
.IX Item "view_prefix"
Prefix of methods which should be mapped to \fIview()\fR by \s-1AUTOLOAD\s0.  Defaults
to 'view_'.
.Sp
.Vb 2
\&    [% USE view %]
\&    [% view.view_header() %]                    # => view('header')
.Ve
.Sp
.Vb 2
\&    [% USE view(view_prefix => 'show_me_the_' %]
\&    [% view.show_me_the_header() %]             # => view('header')
.Ve
.IP "view_naked" 4
.IX Item "view_naked"
Flag to indcate if any attempt should be made to map method names to 
template names where they don't match the view_prefix.  Defaults to 0.
.Sp
.Vb 1
\&    [% USE view(view_naked => 1) %]
.Ve
.Sp
.Vb 1
\&    [% view.header() %]                 # => view('header')
.Ve
.ie n .Sh "print( $obj1\fP, \f(CW$obj2, ... \e%config)"
.el .Sh "print( \f(CW$obj1\fP, \f(CW$obj2\fP, ... \e%config)"
.IX Subsection "print( $obj1, $obj2, ... %config)"
\&\s-1TODO\s0
.ie n .Sh "view( $template, \e%vars, \e%config );"
.el .Sh "view( \f(CW$template\fP, \e%vars, \e%config );"
.IX Subsection "view( $template, %vars, %config );"
\&\s-1TODO\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org> <http://wardley.org/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000\-2007 Andy Wardley.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template::Plugin
