.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Template::Context 3"
.TH Template::Context 3 "2011-07-25" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Template::Context \- Runtime context in which templates are processed
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Template::Context;
.Ve
.PP
.Vb 3
\&    # constructor
\&    $context = Template::Context->new(\e%config)
\&        || die $Template::Context::ERROR;
.Ve
.PP
.Vb 2
\&    # fetch (load and compile) a template
\&    $template = $context->template($template_name);
.Ve
.PP
.Vb 2
\&    # fetch (load and instantiate) a plugin object
\&    $plugin = $context->plugin($name, \e@args);
.Ve
.PP
.Vb 2
\&    # fetch (return or create) a filter subroutine
\&    $filter = $context->filter($name, \e@args, $alias);
.Ve
.PP
.Vb 3
\&    # process/include a template, errors are thrown via die()
\&    $output = $context->process($template, \e%vars);
\&    $output = $context->include($template, \e%vars);
.Ve
.PP
.Vb 2
\&    # raise an exception via die()
\&    $context->throw($error_type, $error_message, \e$output_buffer);
.Ve
.PP
.Vb 2
\&    # catch an exception, clean it up and fix output buffer
\&    $exception = $context->catch($exception, \e$output_buffer);
.Ve
.PP
.Vb 3
\&    # save/restore the stash to effect variable localisation
\&    $new_stash = $context->localise(\e%vars);
\&    $old_stash = $context->delocalise();
.Ve
.PP
.Vb 3
\&    # add new BLOCK or FILTER definitions
\&    $context->define_block($name, $block);
\&    $context->define_filter($name, \e&filtersub, $is_dynamic);
.Ve
.PP
.Vb 2
\&    # reset context, clearing any imported BLOCK definitions
\&    $context->reset();
.Ve
.PP
.Vb 8
\&    # methods for accessing internal items
\&    $stash     = $context->stash();
\&    $tflag     = $context->trim();
\&    $epflag    = $context->eval_perl();
\&    $providers = $context->templates();
\&    $providers = $context->plugins();
\&    $providers = $context->filters();
\&    ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Template::Context\*(C'\fR module defines an object class for representing
a runtime context in which templates are processed.  It provides an
interface to the fundamental operations of the Template Toolkit
processing engine through which compiled templates (i.e. Perl code
constructed from the template source) can process templates, load
plugins and filters, raise exceptions and so on.
.PP
A default \f(CW\*(C`Template::Context\*(C'\fR object is created by the Template module.
Any \f(CW\*(C`Template::Context\*(C'\fR options may be passed to the Template
\&\fInew()\fR constructor method and will be forwarded to the
\&\f(CW\*(C`Template::Context\*(C'\fR constructor.
.PP
.Vb 1
\&    use Template;
.Ve
.PP
.Vb 8
\&    my $template = Template->new({
\&        TRIM      => 1,
\&        EVAL_PERL => 1,
\&        BLOCKS    => {
\&            header => 'This is the header',
\&            footer => 'This is the footer',
\&        },
\&    });
.Ve
.PP
Similarly, the \f(CW\*(C`Template::Context\*(C'\fR constructor will forward all configuration
parameters onto other default objects (e.g. Template::Provider,
Template::Plugins, Template::Filters, etc.) that it may need to
instantiate.
.PP
.Vb 4
\&    $context = Template::Context->new({
\&        INCLUDE_PATH => '/home/abw/templates', # provider option
\&        TAG_STYLE    => 'html',                # parser option
\&    });
.Ve
.PP
A \f(CW\*(C`Template::Context\*(C'\fR object (or subclass) can be explicitly instantiated and
passed to the Template \fInew()\fR constructor method as the
\&\f(CW\*(C`CONTEXT\*(C'\fR configuration item.
.PP
.Vb 2
\&    use Template;
\&    use Template::Context;
.Ve
.PP
.Vb 2
\&    my $context  = Template::Context->new({ TRIM => 1 });
\&    my $template = Template->new({ CONTEXT => $context });
.Ve
.PP
The Template module uses the Template::Config
\&\fIcontext()\fR factory method to create a default
context object when required. The \f(CW$Template::Config::CONTEXT\fR package
variable may be set to specify an alternate context module. This will be
loaded automatically and its \fInew()\fR constructor method called by the
\&\fIcontext()\fR factory method when a default context
object is required.
.PP
.Vb 1
\&    use Template;
.Ve
.PP
.Vb 1
\&    $Template::Config::CONTEXT = 'MyOrg::Template::Context';
.Ve
.PP
.Vb 5
\&    my $template = Template->new({
\&        EVAL_PERL   => 1,
\&        EXTRA_MAGIC => 'red hot',  # your extra config items
\&        ...
\&    });
.Ve
.SH "METHODS"
.IX Header "METHODS"
.Sh "new(\e%params)"
.IX Subsection "new(%params)"
The \f(CW\*(C`new()\*(C'\fR constructor method is called to instantiate a
\&\f(CW\*(C`Template::Context\*(C'\fR object. Configuration parameters may be specified as a
\&\s-1HASH\s0 reference or as a list of \f(CW\*(C`name => value\*(C'\fR pairs.
.PP
.Vb 4
\&    my $context = Template::Context->new({
\&        INCLUDE_PATH => 'header',
\&        POST_PROCESS => 'footer',
\&    });
.Ve
.PP
.Vb 1
\&    my $context = Template::Context->new( EVAL_PERL => 1 );
.Ve
.PP
The \f(CW\*(C`new()\*(C'\fR method returns a \f(CW\*(C`Template::Context\*(C'\fR object or \f(CW\*(C`undef\*(C'\fR on
error. In the latter case, a relevant error message can be retrieved by the
\&\fIerror()\fR class method or directly from the
\&\f(CW$Template::Context::ERROR\fR package variable.
.PP
.Vb 2
\&    my $context = Template::Context->new(\e%config)
\&        || die Template::Context->error();
.Ve
.PP
.Vb 2
\&    my $context = Template::Context->new(\e%config)
\&        || die $Template::Context::ERROR;
.Ve
.PP
The following configuration items may be specified.  Please see 
Template::Manual::Config for further details.
.PP
\fI\s-1VARIABLES\s0\fR
.IX Subsection "VARIABLES"
.PP
The \s-1VARIABLES\s0 option can be used to
specify a hash array of template variables.
.PP
.Vb 7
\&    my $context = Template::Context->new({
\&        VARIABLES => {
\&            title   => 'A Demo Page',
\&            author  => 'Joe Random Hacker',
\&            version => 3.14,
\&        },
\&    };
.Ve
.PP
\fI\s-1BLOCKS\s0\fR
.IX Subsection "BLOCKS"
.PP
The \s-1BLOCKS\s0 option can be used to pre-define
a default set of template blocks.
.PP
.Vb 7
\&    my $context = Template::Context->new({
\&        BLOCKS => {
\&            header  => 'The Header.  [% title %]',
\&            footer  => sub { return $some_output_text },
\&            another => Template::Document->new({ ... }),
\&        },
\&    });
.Ve
.PP
\fI\s-1VIEWS\s0\fR
.IX Subsection "VIEWS"
.PP
The \s-1VIEWS\s0 option can be used to pre-define 
one or more Template::View objects.
.PP
.Vb 7
\&    my $context = Template::Context->new({
\&        VIEWS => [
\&            bottom => { prefix => 'bottom/' },
\&            middle => { prefix => 'middle/', base => 'bottom' },
\&            top    => { prefix => 'top/',    base => 'middle' },
\&        ],
\&    });
.Ve
.PP
\fI\s-1TRIM\s0\fR
.IX Subsection "TRIM"
.PP
The \s-1TRIM\s0 option can be set to have any
leading and trailing whitespace automatically removed from the output of all
template files and \f(CW\*(C`BLOCK\*(C'\fRs.
.PP
example:
.PP
.Vb 1
\&    [% BLOCK foo %]
.Ve
.PP
.Vb 1
\&    Line 1 of foo
.Ve
.PP
.Vb 1
\&    [% END %]
.Ve
.PP
.Vb 3
\&    before 
\&    [% INCLUDE foo %]
\&    after
.Ve
.PP
output:
.PP
.Vb 3
\&    before
\&    Line 1 of foo
\&    after
.Ve
.PP
\fI\s-1EVAL_PERL\s0\fR
.IX Subsection "EVAL_PERL"
.PP
The \s-1EVAL_PERL\s0 is used to indicate if
\&\f(CW\*(C`PERL\*(C'\fR and/or \f(CW\*(C`RAWPERL\*(C'\fR blocks should be evaluated. It is disabled by
default.
.PP
\fI\s-1RECURSION\s0\fR
.IX Subsection "RECURSION"
.PP
The \s-1RECURSION\s0 can be set to 
allow templates to recursively process themselves, either directly
(e.g. template \f(CW\*(C`foo\*(C'\fR calls \f(CW\*(C`INCLUDE foo\*(C'\fR) or indirectly (e.g. 
\&\f(CW\*(C`foo\*(C'\fR calls \f(CW\*(C`INCLUDE bar\*(C'\fR which calls \f(CW\*(C`INCLUDE foo\*(C'\fR).
.PP
\fI\s-1LOAD_TEMPLATES\s0\fR
.IX Subsection "LOAD_TEMPLATES"
.PP
The \s-1LOAD_TEMPLATES\s0 option can be
used to provide a reference to a list of Template::Provider objects or
sub-classes thereof which will take responsibility for loading and compiling
templates.
.PP
.Vb 6
\&    my $context = Template::Context->new({
\&        LOAD_TEMPLATES => [
\&            MyOrg::Template::Provider->new({ ... }),
\&            Template::Provider->new({ ... }),
\&        ],
\&    });
.Ve
.PP
\fI\s-1LOAD_PLUGINS\s0\fR
.IX Subsection "LOAD_PLUGINS"
.PP
The \s-1LOAD_PLUGINS\s0 options can be used
to specify a list of provider objects responsible for loading and
instantiating template plugin objects.
.PP
.Vb 6
\&    my $context = Template::Context->new({
\&        LOAD_PLUGINS => [
\&            MyOrg::Template::Plugins->new({ ... }),
\&            Template::Plugins->new({ ... }),
\&        ],
\&    });
.Ve
.PP
\fI\s-1LOAD_FILTERS\s0\fR
.IX Subsection "LOAD_FILTERS"
.PP
The \s-1LOAD_FILTERS\s0 option can be used
to specify a list of provider objects for returning and/or creating filter
subroutines.
.PP
.Vb 6
\&    my $context = Template::Context->new({
\&        LOAD_FILTERS => [
\&            MyTemplate::Filters->new(),
\&            Template::Filters->new(),
\&        ],
\&    });
.Ve
.PP
\fI\s-1STASH\s0\fR
.IX Subsection "STASH"
.PP
The \s-1STASH\s0 option can be used to 
specify a Template::Stash object or sub-class which will take
responsibility for managing template variables.  
.PP
.Vb 4
\&    my $stash = MyOrg::Template::Stash->new({ ... });
\&    my $context = Template::Context->new({
\&        STASH => $stash,
\&    });
.Ve
.PP
\fI\s-1DEBUG\s0\fR
.IX Subsection "DEBUG"
.PP
The \s-1DEBUG\s0 option can be used to enable
various debugging features of the Template::Context module.
.PP
.Vb 1
\&    use Template::Constants qw( :debug );
.Ve
.PP
.Vb 3
\&    my $template = Template->new({
\&        DEBUG => DEBUG_CONTEXT | DEBUG_DIRS,
\&    });
.Ve
.Sh "template($name)"
.IX Subsection "template($name)"
Returns a compiled template by querying each of the \s-1LOAD_TEMPLATES\s0 providers
(instances of Template::Provider, or sub\-class) in turn.  
.PP
.Vb 1
\&    $template = $context->template('header');
.Ve
.PP
On error, a Template::Exception object of type '\f(CW\*(C`file\*(C'\fR' is thrown via
\&\f(CW\*(C`die()\*(C'\fR.  This can be caught by enclosing the call to \f(CW\*(C`template()\*(C'\fR in an
\&\f(CW\*(C`eval\*(C'\fR block and examining \f(CW$@\fR.
.PP
.Vb 4
\&    eval { $template = $context->template('header') };
\&    if ($@) {
\&        print "failed to fetch template: $@\en";
\&    }
.Ve
.Sh "plugin($name, \e@args)"
.IX Subsection "plugin($name, @args)"
Instantiates a plugin object by querying each of the \s-1LOAD_PLUGINS\s0
providers. The default \s-1LOAD_PLUGINS\s0 provider is a Template::Plugins
object which attempts to load plugin modules, according the various
configuration items such as \s-1PLUGIN_BASE\s0,
\&\s-1LOAD_PERL\s0, etc., and then instantiate an object
via \fInew()\fR. A reference to a list of constructor
arguments may be passed as the second parameter. These are forwarded to the
plugin constructor.
.PP
Returns a reference to a plugin (which is generally an object, but
doesn't have to be).  Errors are thrown as Template::Exception objects
with the type set to '\f(CW\*(C`plugin\*(C'\fR'.
.PP
.Vb 1
\&    $plugin = $context->plugin('DBI', 'dbi:msql:mydbname');
.Ve
.ie n .Sh "filter($name, \e@args, $alias)"
.el .Sh "filter($name, \e@args, \f(CW$alias\fP)"
.IX Subsection "filter($name, @args, $alias)"
Instantiates a filter subroutine by querying the \s-1LOAD_FILTERS\s0 providers.
The default \s-1LOAD_FILTERS\s0 provider is a Template::Filters object.
.PP
Additional arguments may be passed by list reference along with an optional
alias under which the filter will be cached for subsequent use. The filter is
cached under its own \f(CW$name\fR if \f(CW$alias\fR is undefined. Subsequent calls to
\&\f(CW\*(C`filter($name)\*(C'\fR will return the cached entry, if defined. Specifying arguments
bypasses the caching mechanism and always creates a new filter. Errors are
thrown as Template::Exception objects with the type set to '\f(CW\*(C`filter\*(C'\fR'.
.PP
.Vb 2
\&    # static filter (no args)
\&    $filter = $context->filter('html');
.Ve
.PP
.Vb 2
\&    # dynamic filter (args) aliased to 'padright'
\&    $filter = $context->filter('format', '%60s', 'padright');
.Ve
.PP
.Vb 2
\&    # retrieve previous filter via 'padright' alias
\&    $filter = $context->filter('padright');
.Ve
.Sh "process($template, \e%vars)"
.IX Subsection "process($template, %vars)"
Processes a template named or referenced by the first parameter and returns
the output generated.  An optional reference to a hash array may be passed
as the second parameter, containing variable definitions which will be set
before the template is processed.  The template is processed in the current
context, with no localisation of variables performed.   Errors are thrown
as Template::Exception objects via \f(CW\*(C`die()\*(C'\fR.  
.PP
.Vb 1
\&    $output = $context->process('header', { title => 'Hello World' });
.Ve
.Sh "include($template, \e%vars)"
.IX Subsection "include($template, %vars)"
Similar to \fIprocess()\fR, but using localised variables.  Changes made to
any variables will only persist until the \f(CW\*(C`include()\*(C'\fR method completes.
.PP
.Vb 1
\&    $output = $context->include('header', { title => 'Hello World' });
.Ve
.ie n .Sh "throw($error_type, $error_message, \e$output)"
.el .Sh "throw($error_type, \f(CW$error_message\fP, \e$output)"
.IX Subsection "throw($error_type, $error_message, $output)"
Raises an exception in the form of a Template::Exception object by calling
\&\f(CW\*(C`die()\*(C'\fR. This method may be passed a reference to an existing
Template::Exception object; a single value containing an error message
which is used to instantiate a Template::Exception of type '\f(CW\*(C`undef\*(C'\fR'; or a
pair of values representing the exception \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`info\*(C'\fR from which a
Template::Exception object is instantiated. e.g.
.PP
.Vb 3
\&    $context->throw($exception);
\&    $context->throw("I'm sorry Dave, I can't do that");
\&    $context->throw('denied', "I'm sorry Dave, I can't do that");
.Ve
.PP
The optional third parameter may be a reference to the current output
buffer.  This is then stored in the exception object when created,
allowing the catcher to examine and use the output up to the point at
which the exception was raised.
.PP
.Vb 3
\&    $output .= 'blah blah blah';
\&    $output .= 'more rhubarb';
\&    $context->throw('yack', 'Too much yacking', \e$output);
.Ve
.Sh "catch($exception, \e$output)"
.IX Subsection "catch($exception, $output)"
Catches an exception thrown, either as a reference to a Template::Exception
object or some other value. In the latter case, the error string is promoted
to a Template::Exception object of '\f(CW\*(C`undef\*(C'\fR' type. This method also
accepts a reference to the current output buffer which is passed to the
Template::Exception constructor, or is appended to the output buffer stored
in an existing Template::Exception object, if unique (i.e. not the same
reference). By this process, the correct state of the output buffer can be
reconstructed for simple or nested throws.
.ie n .Sh "define_block($name, $block)"
.el .Sh "define_block($name, \f(CW$block\fP)"
.IX Subsection "define_block($name, $block)"
Adds a new block definition to the internal \s-1BLOCKS\s0 cache.  The first 
argument should contain the name of the block and the second a reference
to a Template::Document object or template sub\-routine, or template text
which is automatically compiled into a template sub\-routine.  
.PP
Returns a true value (the sub-routine or Template::Document reference) on
success or undef on failure. The relevant error message can be retrieved by
calling the \fIerror()\fR method.
.ie n .Sh "define_filter($name, \e&filter, $is_dynamic)"
.el .Sh "define_filter($name, \e&filter, \f(CW$is_dynamic\fP)"
.IX Subsection "define_filter($name, &filter, $is_dynamic)"
Adds a new filter definition by calling the
\&\fIstore()\fR method on each of the \s-1LOAD_FILTERS\s0
providers until accepted (in the usual case, this is accepted straight away by
the one and only Template::Filters provider). The first argument should
contain the name of the filter and the second a reference to a filter
subroutine. The optional third argument can be set to any true value to
indicate that the subroutine is a dynamic filter factory. 
.PP
Returns a true value or throws a '\f(CW\*(C`filter\*(C'\fR' exception on error.
.Sh "define_view($name, \e%params)"
.IX Subsection "define_view($name, %params)"
This method allows you to define a named view.
.PP
.Vb 5
\&    $context->define_view( 
\&        my_view => { 
\&            prefix => 'my_templates/' 
\&        } 
\&    );
.Ve
.PP
The view is then accessible as a template variable.
.PP
.Vb 1
\&    [% my_view.print(some_data) %]
.Ve
.Sh "define_views($views)"
.IX Subsection "define_views($views)"
This method allows you to define multiple named views.
A reference to a hash array or list reference should be passed as an argument.
.PP
.Vb 8
\&    $context->define_view({     # hash reference
\&        my_view_one => { 
\&            prefix => 'my_templates_one/' 
\&        },
\&        my_view_two => { 
\&            prefix => 'my_templates_two/' 
\&        } 
\&    });
.Ve
.PP
If you're defining multiple views of which one or more are based on other 
views in the same definition then you should pass them as a list reference.
This ensures that they get created in the right order (Perl does not preserve
the order of items defined in a hash reference so you can't guarantee that
your base class view will be defined before your subclass view).
.PP
.Vb 9
\&    $context->define_view([     # list referenence
\&        my_view_one => {
\&            prefix => 'my_templates_one/' 
\&        },
\&        my_view_two => { 
\&            prefix => 'my_templates_two/' ,
\&            base   => 'my_view_one',
\&        } 
\&    ]);
.Ve
.PP
The views are then accessible as template variables.
.PP
.Vb 2
\&    [% my_view_one.print(some_data) %]
\&    [% my_view_two.print(some_data) %]
.Ve
.PP
See also the \s-1VIEWS\s0 option.
.Sh "localise(\e%vars)"
.IX Subsection "localise(%vars)"
Clones the stash to create a context with localised variables.  Returns a 
reference to the newly cloned stash object which is also stored
internally.
.PP
.Vb 1
\&    $stash = $context->localise();
.Ve
.Sh "\fIdelocalise()\fP"
.IX Subsection "delocalise()"
Restore the stash to its state prior to localisation.
.PP
.Vb 1
\&    $stash = $context->delocalise();
.Ve
.Sh "visit(\e%blocks)"
.IX Subsection "visit(%blocks)"
This method is called by Template::Document objects immediately before
they process their content.  It is called to register any local \f(CW\*(C`BLOCK\*(C'\fR
definitions with the context object so that they may be subsequently
delivered on request.
.Sh "\fIleave()\fP"
.IX Subsection "leave()"
Compliment to the \fIvisit()\fR method. Called by Template::Document objects
immediately after they process their content.
.Sh "\fIreset()\fP"
.IX Subsection "reset()"
Clears the local \s-1BLOCKS\s0 cache of any \f(CW\*(C`BLOCK\*(C'\fR definitions.  Any initial set of
\&\s-1BLOCKS\s0 specified as a configuration item to the constructor will be reinstated.
.Sh "\s-1AUTOLOAD\s0"
.IX Subsection "AUTOLOAD"
An \f(CW\*(C`AUTOLOAD\*(C'\fR method provides access to context configuration items.
.PP
.Vb 4
\&    $stash     = $context->stash();
\&    $tflag     = $context->trim();
\&    $epflag    = $context->eval_perl();
\&    ...
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org> <http://wardley.org/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1996\-2007 Andy Wardley.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template, Template::Document, Template::Exception,
Template::Filters, Template::Plugins, Template::Provider,
Template::Service, Template::Stash
