.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Template::Stash 3"
.TH Template::Stash 3 "2011-07-25" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Template::Stash \- Magical storage for template variables
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Template::Stash;
.Ve
.PP
.Vb 1
\&    my $stash = Template::Stash->new(\e%vars);
.Ve
.PP
.Vb 3
\&    # get variable values
\&    $value = $stash->get($variable);
\&    $value = $stash->get(\e@compound);
.Ve
.PP
.Vb 3
\&    # set variable value
\&    $stash->set($variable, $value);
\&    $stash->set(\e@compound, $value);
.Ve
.PP
.Vb 3
\&    # default variable value
\&    $stash->set($variable, $value, 1);
\&    $stash->set(\e@compound, $value, 1);
.Ve
.PP
.Vb 2
\&    # set variable values en masse
\&    $stash->update(\e%new_vars)
.Ve
.PP
.Vb 3
\&    # methods for (de-)localising variables
\&    $stash = $stash->clone(\e%new_vars);
\&    $stash = $stash->declone();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Template::Stash\*(C'\fR module defines an object class which is used to store
variable values for the runtime use of the template processor.  Variable
values are stored internally in a hash reference (which itself is blessed 
to create the object) and are accessible via the \fIget()\fR and \fIset()\fR methods.
.PP
Variables may reference hash arrays, lists, subroutines and objects
as well as simple values.  The stash automatically performs the right
magic when dealing with variables, calling code or object methods,
indexing into lists, hashes, etc.
.PP
The stash has \fIclone()\fR and \fIdeclone()\fR methods which are used by the
template processor to make temporary copies of the stash for
localising changes made to variables.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.Sh "new(\e%params)"
.IX Subsection "new(%params)"
The \f(CW\*(C`new()\*(C'\fR constructor method creates and returns a reference to a new
\&\f(CW\*(C`Template::Stash\*(C'\fR object.  
.PP
.Vb 1
\&    my $stash = Template::Stash->new();
.Ve
.PP
A hash reference may be passed to provide variables and values which
should be used to initialise the stash.
.PP
.Vb 2
\&    my $stash = Template::Stash->new({ var1 => 'value1', 
\&                                       var2 => 'value2' });
.Ve
.Sh "get($variable)"
.IX Subsection "get($variable)"
The \f(CW\*(C`get()\*(C'\fR method retrieves the variable named by the first parameter.
.PP
.Vb 1
\&    $value = $stash->get('var1');
.Ve
.PP
Dotted compound variables can be retrieved by specifying the variable
elements by reference to a list.  Each node in the variable occupies
two entries in the list.  The first gives the name of the variable
element, the second is a reference to a list of arguments for that 
element, or \f(CW0\fR if none.
.PP
.Vb 1
\&    [% foo.bar(10).baz(20) %]
.Ve
.PP
.Vb 1
\&    $stash->get([ 'foo', 0, 'bar', [ 10 ], 'baz', [ 20 ] ]);
.Ve
.ie n .Sh "set($variable, $value\fP, \f(CW$default)"
.el .Sh "set($variable, \f(CW$value\fP, \f(CW$default\fP)"
.IX Subsection "set($variable, $value, $default)"
The \f(CW\*(C`set()\*(C'\fR method sets the variable name in the first parameter to the 
value specified in the second.
.PP
.Vb 1
\&    $stash->set('var1', 'value1');
.Ve
.PP
If the third parameter evaluates to a true value, the variable is
set only if it did not have a true value before.
.PP
.Vb 1
\&    $stash->set('var2', 'default_value', 1);
.Ve
.PP
Dotted compound variables may be specified as per \fIget()\fR above.
.PP
.Vb 1
\&    [% foo.bar = 30 %]
.Ve
.PP
.Vb 1
\&    $stash->set([ 'foo', 0, 'bar', 0 ], 30);
.Ve
.PP
The magical variable '\f(CW\*(C`IMPORT\*(C'\fR' can be specified whose corresponding
value should be a hash reference.  The contents of the hash array are
copied (i.e. imported) into the current namespace.
.PP
.Vb 2
\&    # foo.bar = baz, foo.wiz = waz
\&    $stash->set('foo', { 'bar' => 'baz', 'wiz' => 'waz' });
.Ve
.PP
.Vb 2
\&    # import 'foo' into main namespace: bar = baz, wiz = waz
\&    $stash->set('IMPORT', $stash->get('foo'));
.Ve
.Sh "clone(\e%params)"
.IX Subsection "clone(%params)"
The \f(CW\*(C`clone()\*(C'\fR method creates and returns a new \f(CW\*(C`Template::Stash\*(C'\fR object
which represents a localised copy of the parent stash. Variables can be freely
updated in the cloned stash and when \fIdeclone()\fR is called, the original stash
is returned with all its members intact and in the same state as they were
before \f(CW\*(C`clone()\*(C'\fR was called.
.PP
For convenience, a hash of parameters may be passed into \f(CW\*(C`clone()\*(C'\fR which 
is used to update any simple variable (i.e. those that don't contain any 
namespace elements like \f(CW\*(C`foo\*(C'\fR and \f(CW\*(C`bar\*(C'\fR but not \f(CW\*(C`foo.bar\*(C'\fR) variables while 
cloning the stash.  For adding and updating complex variables, the \fIset()\fR 
method should be used after calling \f(CW\*(C`clone().\*(C'\fR  This will correctly resolve
and/or create any necessary namespace hashes.
.PP
A cloned stash maintains a reference to the stash that it was copied 
from in its \f(CW\*(C`_PARENT\*(C'\fR member.
.Sh "\fIdeclone()\fP"
.IX Subsection "declone()"
The \f(CW\*(C`declone()\*(C'\fR method returns the \f(CW\*(C`_PARENT\*(C'\fR reference and can be used to
restore the state of a stash as described above.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org> <http://wardley.org/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1996\-2007 Andy Wardley.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template, Template::Context
